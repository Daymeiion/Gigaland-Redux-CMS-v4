{"version":3,"file":"index.es.js","sources":["../src/components/ImageStage/utils/getTranslateOffsetsFromScale.ts","../src/components/ImageStage/utils/imageIsOutOfBounds.ts","../src/components/ImageStage/components/Image/index.tsx","../src/components/ImageStage/utils/useDoubleClick.tsx","../src/components/ImageStage/components/ImagePager/index.tsx","../src/components/ImageStage/utils/useWindowSize.tsx","../src/components/ImageStage/index.tsx","../src/components/PageContainer/index.tsx","../src/components/CreatePortal/index.tsx","../src/index.tsx"],"sourcesContent":["type IGetTranslateOffsetsFromScale = {\n    /** The current [x,y] translate values of image */\n    currentTranslate: [translateX: number, translateY: number];\n    /** The image dom node used as a reference to calculate translate offsets */\n    imageRef: React.RefObject<HTMLImageElement>;\n    /** The amount of change in the new transform scale */\n    pinchDelta: number;\n    /** The current transform scale of image */\n    scale: number;\n    /** The [x,y] coordinates of the zoom origin */\n    touchOrigin: [touchOriginX: number, touchOriginY: number];\n};\n\ntype ITranslateOffsetsReturnType = [translateX: number, translateY: number];\n\n/**\n * Calculates the the translate(x,y) coordinates needed to zoom-in\n * to a point in an image.\n *\n * @returns {array} The next [x,y] translate values to apply to image\n */\nconst getTranslateOffsetsFromScale = ({\n    imageRef,\n    scale,\n    pinchDelta,\n    touchOrigin: [touchOriginX, touchOriginY],\n    currentTranslate: [translateX, translateY],\n}: IGetTranslateOffsetsFromScale): ITranslateOffsetsReturnType => {\n    if (!imageRef?.current) {\n        return [0, 0];\n    }\n\n    const {\n        height: imageHeight,\n        left: imageTopLeftX,\n        top: imageTopLeftY,\n        width: imageWidth,\n    } = imageRef.current?.getBoundingClientRect();\n\n    // Get the (x,y) touch position relative to image origin at the current scale\n    const imageCoordX = (touchOriginX - imageTopLeftX - imageWidth / 2) / scale;\n    const imageCoordY =\n        (touchOriginY - imageTopLeftY - imageHeight / 2) / scale;\n\n    // Calculate translateX/Y offset at the next scale to zoom to touch position\n    const newTranslateX = -imageCoordX * pinchDelta + translateX;\n    const newTranslateY = -imageCoordY * pinchDelta + translateY;\n\n    return [newTranslateX, newTranslateY];\n};\n\nexport default getTranslateOffsetsFromScale;\n","/**\n * Determines if the provided image is within the viewport\n *\n * @returns True if image needs to be resized to fit viewport, otherwise false\n */\nconst imageIsOutOfBounds = (\n    imageRef: React.RefObject<HTMLImageElement>\n): boolean => {\n    // If no ref is provided, return false\n    if (!imageRef.current) {\n        return false;\n    }\n\n    const {\n        bottom: bottomRightY,\n        left: topLeftX,\n        right: bottomRightX,\n        top: topLeftY,\n    } = imageRef.current?.getBoundingClientRect();\n    const { innerHeight: windowHeight, innerWidth: windowWidth } = window;\n\n    if (\n        topLeftX > windowWidth * (1 / 2) ||\n        topLeftY > windowHeight * (1 / 2) ||\n        bottomRightX < windowWidth * (1 / 2) ||\n        bottomRightY < windowHeight * (1 / 2)\n    )\n        return true;\n\n    return false;\n};\n\nexport default imageIsOutOfBounds;\n","import React, { useEffect, useState, useRef } from 'react';\nimport { useSpring, animated, to } from '@react-spring/web';\nimport { useGesture } from 'react-use-gesture';\nimport styled from 'styled-components';\nimport {\n    useDoubleClick,\n    imageIsOutOfBounds,\n    getTranslateOffsetsFromScale,\n} from '../../utils';\nimport type { ImagesListItem } from '../../../../types/ImagesList';\n\nconst defaultImageTransform = {\n    pinching: false,\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n};\n\ntype IImageProps = {\n    /** Any valid <img /> props to pass to the lightbox img element ie src, alt, caption etc*/\n    imgProps: ImagesListItem;\n    /** True if this image is currently shown in pager, otherwise false */\n    isCurrentImage: boolean;\n    /** Fixed height of the image stage, used to restrict maximum height of images */\n    pagerHeight: '100%' | number;\n    /** Indicates parent ImagePager is in a state of dragging, if true click to zoom is disabled */\n    pagerIsDragging: boolean;\n    /** Function that can be called to disable dragging in the pager */\n    setDisableDrag: (disable: boolean) => void;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n};\n\n/**\n * Animates pinch-zoom + panning on image using spring physics\n */\nconst Image = ({\n    imgProps: { style: imgStyleProp, ...restImgProps },\n    isCurrentImage,\n    pagerHeight,\n    pagerIsDragging,\n    setDisableDrag,\n    singleClickToZoom,\n}: IImageProps) => {\n    const [isPanningImage, setIsPanningImage] = useState<boolean>(false);\n    const imageRef = useRef<HTMLImageElement>(null);\n\n    /**\n     * Animates scale and translate offsets of Image as they change in gestures\n     *\n     * @see https://www.react-spring.io/docs/hooks/use-spring\n     */\n    const [{ scale, translateX, translateY }, springApi] = useSpring(() => ({\n        ...defaultImageTransform,\n        onChange: (result, instance) => {\n            if (result.value.scale < 1 || !result.value.pinching) {\n                instance.start(defaultImageTransform);\n            }\n\n            if (result.value.scale > 1 && imageIsOutOfBounds(imageRef)) {\n                instance.start(defaultImageTransform);\n            }\n        },\n        // Enable dragging in ImagePager if image is at the default size\n        onRest: (result, instance) => {\n            if (result.value.scale === 1) {\n                instance.start(defaultImageTransform);\n                setDisableDrag(false);\n            }\n        },\n    }));\n\n    // Reset scale of this image when dragging to new image in ImagePager\n    useEffect(() => {\n        if (!isCurrentImage && scale.get() !== 1) {\n            springApi.start(defaultImageTransform);\n        }\n    }, [isCurrentImage, scale, springApi]);\n\n    /**\n     * Update Image scale and translate offsets during pinch/pan gestures\n     *\n     * @see https://github.com/react-spring/react-use-gesture#usegesture-hook-supporting-multiple-gestures-at-once\n     */\n    useGesture(\n        {\n            onDrag: ({\n                movement: [xMovement, yMovement],\n                pinching,\n                cancel,\n                first,\n                memo = { initialTranslateX: 0, initialTranslateY: 0 },\n                touches,\n                tap,\n            }) => {\n                if (pagerIsDragging || scale.get() === 1 || tap) {\n                    return;\n                }\n\n                // Disable click to zoom during drag\n                if (xMovement && yMovement && !isPanningImage) {\n                    setIsPanningImage(true);\n                }\n\n                if (touches > 1) return;\n                if (pinching || scale.get() <= 1) return;\n\n                // Prevent dragging image out of viewport\n                if (scale.get() > 1 && imageIsOutOfBounds(imageRef)) {\n                    cancel();\n                    return;\n                } else {\n                    if (first) {\n                        return {\n                            initialTranslateX: translateX.get(),\n                            initialTranslateY: translateY.get(),\n                        };\n                    }\n\n                    // Translate image from dragging\n                    springApi.start({\n                        translateX: memo.initialTranslateX + xMovement,\n                        translateY: memo.initialTranslateY + yMovement,\n                    });\n\n                    return memo;\n                }\n            },\n            onDragEnd: ({ memo }) => {\n                if (memo !== undefined) {\n                    // Add small timeout to prevent onClick handler from firing after drag\n                    setTimeout(() => setIsPanningImage(false), 100);\n                }\n            },\n            onPinch: ({\n                movement: [xMovement],\n                origin: [touchOriginX, touchOriginY],\n                event,\n                ctrlKey,\n                last,\n                cancel,\n            }) => {\n                if (pagerIsDragging) {\n                    return;\n                }\n\n                // Prevent ImagePager from registering isDragging\n                setDisableDrag(true);\n\n                // Disable click to zoom during pinch\n                if (xMovement && !isPanningImage) setIsPanningImage(true);\n\n                // Don't calculate new translate offsets on final frame\n                if (last) {\n                    cancel();\n                    return;\n                }\n\n                // Speed up pinch zoom when using mouse versus touch\n                const SCALE_FACTOR = ctrlKey ? 1000 : 250;\n                const pinchScale = scale.get() + xMovement / SCALE_FACTOR;\n                const pinchDelta = pinchScale - scale.get();\n\n                /**\n                 * Calculate touch origin for pinch/zoom\n                 *\n                 * if event is a touch event (React.TouchEvent<Element>, TouchEvent or WebKitGestureEvent) use touchOriginX/Y\n                 * if event is a wheel event (React.WheelEvent<Element> or WheelEvent) use the mouse cursor's clientX/Y\n                 */\n                let touchOrigin: [touchOriginX: number, touchOriginY: number] =\n                    [touchOriginX, touchOriginY];\n                if ('clientX' in event && 'clientY' in event && ctrlKey) {\n                    touchOrigin = [event.clientX, event.clientY];\n                }\n\n                // Calculate the amount of x, y translate offset needed to\n                // zoom-in to point as image scale grows\n                const [newTranslateX, newTranslateY] =\n                    getTranslateOffsetsFromScale({\n                        currentTranslate: [translateX.get(), translateY.get()],\n                        imageRef,\n                        pinchDelta,\n                        scale: scale.get(),\n                        // Use the [x, y] coords of mouse if a trackpad or ctrl + wheel event\n                        // Otherwise use touch origin\n                        touchOrigin,\n                    });\n\n                // Restrict the amount of zoom between half and 3x image size\n                if (pinchScale < 0.5)\n                    springApi.start({ pinching: true, scale: 0.5 });\n                else if (pinchScale > 3.0)\n                    springApi.start({ pinching: true, scale: 3.0 });\n                else\n                    springApi.start({\n                        pinching: true,\n                        scale: pinchScale,\n                        translateX: newTranslateX,\n                        translateY: newTranslateY,\n                    });\n            },\n            onPinchEnd: () => {\n                if (!pagerIsDragging) {\n                    if (scale.get() > 1) setDisableDrag(true);\n                    else springApi.start(defaultImageTransform);\n                    // Add small timeout to prevent onClick handler from firing after panning\n                    setTimeout(() => setIsPanningImage(false), 100);\n                }\n            },\n        },\n        /**\n         * useGesture config\n         * @see https://github.com/react-spring/react-use-gesture#usegesture-config\n         */\n        {\n            domTarget: imageRef as React.RefObject<EventTarget>,\n            drag: {\n                filterTaps: true,\n            },\n            eventOptions: {\n                passive: false,\n            },\n        }\n    );\n\n    // Handle click/tap on image\n    useDoubleClick({\n        [singleClickToZoom ? 'onSingleClick' : 'onDoubleClick']: (\n            e: MouseEvent\n        ) => {\n            if (pagerIsDragging || isPanningImage) {\n                e.stopPropagation();\n                return;\n            }\n\n            // If tapped while already zoomed-in, zoom out to default scale\n            if (scale.get() !== 1) {\n                springApi.start(defaultImageTransform);\n                return;\n            }\n\n            // Zoom-in to origin of click on image\n            const { clientX: touchOriginX, clientY: touchOriginY } = e;\n            const pinchScale = scale.get() + 1;\n            const pinchDelta = pinchScale - scale.get();\n\n            // Calculate the amount of x, y translate offset needed to\n            // zoom-in to point as image scale grows\n            const [newTranslateX, newTranslateY] = getTranslateOffsetsFromScale(\n                {\n                    currentTranslate: [translateX.get(), translateY.get()],\n                    imageRef,\n                    pinchDelta,\n                    scale: scale.get(),\n                    touchOrigin: [touchOriginX, touchOriginY],\n                }\n            );\n\n            // Disable dragging in pager\n            setDisableDrag(true);\n            springApi.start({\n                pinching: true,\n                scale: pinchScale,\n                translateX: newTranslateX,\n                translateY: newTranslateY,\n            });\n        },\n        latency: singleClickToZoom ? 0 : 200,\n        ref: imageRef,\n    });\n\n    return (\n        <AnimatedImage\n            className=\"lightbox-image\"\n            draggable=\"false\"\n            onClick={(e: React.MouseEvent<HTMLImageElement>) => {\n                // Don't close lighbox when clicking image\n                e.stopPropagation();\n                e.nativeEvent.stopImmediatePropagation();\n            }}\n            onDragStart={(e: React.DragEvent<HTMLImageElement>) => {\n                // Disable image ghost dragging in firefox\n                e.preventDefault();\n            }}\n            ref={imageRef}\n            style={{\n                ...imgStyleProp,\n                maxHeight: pagerHeight,\n                transform: to(\n                    [scale, translateX, translateY],\n                    (s, x, y) => `translate(${x}px, ${y}px) scale(${s})`\n                ),\n                ...(isCurrentImage && { willChange: 'transform' }),\n            }}\n            // Include any valid img html attributes provided in the <Lightbox /> images prop\n            {...(restImgProps as React.ComponentProps<typeof animated.img>)}\n        />\n    );\n};\n\nImage.displayName = 'Image';\n\nexport default Image;\n\nconst AnimatedImage = styled(animated.img)`\n    width: auto;\n    max-width: 100%;\n    user-select: none;\n    touch-action: none;\n    ::selection {\n        background: none;\n    }\n`;\n","import React, { useEffect } from 'react';\n\ntype IUseDoubleClickProps = {\n    /** The amount of time (in milliseconds) to wait before differentiating a single from a double click */\n    latency?: number;\n    /** A callback function for double click events */\n    onDoubleClick?: (event: MouseEvent) => void;\n    /** A callback function for single click events */\n    onSingleClick?: (event: MouseEvent) => void;\n    /** Dom node to watch for double clicks */\n    ref: React.RefObject<HTMLElement>;\n};\n\n/**\n * React Hook that returns the current window size\n * and report updates from the 'resize' window event\n */\nconst useDoubleClick = ({\n    ref,\n    latency = 300,\n    onSingleClick = () => null,\n    onDoubleClick = () => null,\n}: IUseDoubleClickProps) => {\n    useEffect(() => {\n        const clickRef = ref.current;\n        let clickCount = 0;\n        let timer: ReturnType<typeof setTimeout>;\n\n        const handleClick = (e: MouseEvent) => {\n            clickCount += 1;\n\n            timer = setTimeout(() => {\n                if (clickCount === 1) onSingleClick(e);\n                else if (clickCount === 2) onDoubleClick(e);\n\n                clickCount = 0;\n            }, latency);\n        };\n\n        // Add event listener for click events\n        clickRef?.addEventListener('click', handleClick);\n\n        // Remove event listener\n        return () => {\n            clickRef?.removeEventListener('click', handleClick);\n\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n    });\n};\n\nexport default useDoubleClick;\n","import React, { useRef, useEffect, useState } from 'react';\nimport { useSprings, animated } from '@react-spring/web';\nimport { useGesture } from 'react-use-gesture';\nimport styled from 'styled-components';\nimport { useWindowSize } from '../../utils';\nimport Image from '../Image';\nimport type { ImagesList } from '../../../../types/ImagesList';\n\ntype IImagePager = {\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Array of image objects to be shown in Lightbox */\n    images: ImagesList;\n    /** Function that closes the Lightbox */\n    onClose: () => void;\n    /** Function that can be called to disable dragging in the pager */\n    onNext: () => void;\n    /** True if this image is currently shown in pager, otherwise false */\n    onPrev: () => void;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay: () => React.ReactNode;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n};\n\n/**\n * Gesture controlled surface that animates prev/next page changes via spring physics.\n */\nconst ImagePager = ({\n    currentIndex,\n    images,\n    onClose,\n    onNext,\n    onPrev,\n    renderImageOverlay,\n    singleClickToZoom,\n}: IImagePager) => {\n    const firstRender = useRef(true);\n    const imageStageRef = useRef(\n        [...Array(images.length)].map(() =>\n            React.createRef<HTMLDivElement>()\n        ) || []\n    );\n    const { height: windowHeight, width: pageWidth } = useWindowSize();\n    const [disableDrag, setDisableDrag] = useState<boolean>(false);\n    const [pagerHeight, setPagerHeight] = useState<'100%' | number>('100%');\n    const [isDragging, setIsDragging] = useState<boolean>(false);\n\n    // Generate page positions based on current index\n    const getPagePositions = React.useCallback(\n        (i: number, down = false, xDelta = 0) => {\n            const x = (i - currentIndex) * pageWidth + (down ? xDelta : 0);\n            if (i < currentIndex - 1 || i > currentIndex + 1)\n                return { display: 'none', x };\n            return { display: 'flex', x };\n        },\n        [currentIndex, pageWidth]\n    );\n\n    /**\n     * Animates translateX of all images at the same time\n     *\n     * @see https://www.react-spring.io/docs/hooks/use-springs\n     */\n    const [pagerSprings, springsApi] = useSprings(images.length, (i) =>\n        getPagePositions(i)\n    );\n\n    // Determine the absolute height of the image pager\n    useEffect(() => {\n        const currImageRef = imageStageRef?.current[currentIndex];\n        let currPagerHeight = 0;\n\n        if (currImageRef && currImageRef?.current) {\n            currPagerHeight = currImageRef.current.clientHeight - 50;\n        }\n\n        if (pagerHeight !== currPagerHeight) {\n            setPagerHeight(currPagerHeight);\n        }\n    }, [currentIndex, pagerHeight, windowHeight]);\n\n    // Animate page change if currentIndex changes\n    useEffect(() => {\n        // No need to set page position for initial render\n        if (firstRender.current) {\n            firstRender.current = false;\n            return;\n        }\n\n        // Update page positions after prev/next page state change\n        springsApi.start((i) => getPagePositions(i));\n    }, [currentIndex, getPagePositions, springsApi]);\n\n    /**\n     * Update each Image's visibility and translateX offset during dragging\n     *\n     * @see https://github.com/react-spring/react-use-gesture\n     */\n    const bind = useGesture(\n        {\n            onDrag: ({\n                down,\n                movement: [xMovement],\n                direction: [xDir],\n                velocity,\n                distance,\n                cancel,\n                active,\n                touches,\n                tap,\n            }) => {\n                // Disable drag if Image has been zoomed in to allow for panning\n                if (disableDrag || xMovement === 0 || tap) return;\n                if (!isDragging) setIsDragging(true);\n\n                const isHorizontalDrag = Math.abs(xDir) > 0.7;\n                const draggedFarEnough =\n                    down && isHorizontalDrag && distance > pageWidth / 3.5;\n                const draggedFastEnough =\n                    down && isHorizontalDrag && velocity > 2;\n\n                // Handle next/prev image from valid drag\n                if ((draggedFarEnough || draggedFastEnough) && active) {\n                    const goToIndex = xDir > 0 ? -1 : 1;\n\n                    // Cancel gesture event\n                    cancel();\n\n                    if (goToIndex > 0) onNext();\n                    else if (goToIndex < 0) onPrev();\n\n                    return;\n                }\n\n                // Don't move pager during two+ finger touch events, i.e. pinch-zoom\n                if (touches > 1) {\n                    cancel();\n                    return;\n                }\n\n                // Update page x-coordinates for single finger/mouse gestures\n                springsApi.start((i) => getPagePositions(i, down, xMovement));\n                return;\n            },\n            onDragEnd: () => {\n                if (isDragging) {\n                    springsApi.start((i) => getPagePositions(i));\n                    // Add small timeout buffer to prevent event handlers from firing in child Images\n                    setTimeout(() => setIsDragging(false), 100);\n                }\n            },\n            onWheel: ({ velocity, direction: [xDir, yDir], ctrlKey }) => {\n                // Disable drag if Image has been zoomed in to allow for panning\n                if (ctrlKey || disableDrag || velocity === 0) return;\n\n                if (!isDragging) {\n                    setIsDragging(true);\n                }\n\n                const draggedFastEnough = velocity > 1.1;\n\n                // Handle next/prev image from valid drag\n                if (draggedFastEnough) {\n                    const goToIndex = xDir + yDir > 0 ? -1 : 1;\n\n                    if (goToIndex > 0) onNext();\n                    else if (goToIndex < 0) onPrev();\n                }\n            },\n            onWheelEnd: () => {\n                springsApi.start((i) => getPagePositions(i));\n                // Add small timeout buffer to prevent event handlers from firing in child Images\n                setTimeout(() => setIsDragging(false), 100);\n            },\n        },\n        {\n            drag: {\n                filterTaps: true,\n            },\n        }\n    );\n\n    return (\n        <>\n            {pagerSprings.map(({ display, x }, i) => (\n                <AnimatedImagePager\n                    {...bind()}\n                    className=\"lightbox-image-pager\"\n                    key={i}\n                    onClick={() =>\n                        Math.abs(x.get()) < 1 && !disableDrag && onClose()\n                    }\n                    ref={imageStageRef.current[i]}\n                    role=\"presentation\"\n                    style={{\n                        display,\n                        transform: x.to(\n                            (xInterp: number) => `translateX(${xInterp}px)`\n                        ),\n                    }}\n                >\n                    <PagerContentWrapper>\n                        <PagerInnerContentWrapper>\n                            <ImageContainer\n                                onClick={(e) => {\n                                    e.stopPropagation();\n                                    e.nativeEvent.stopImmediatePropagation();\n                                }}\n                            >\n                                <Image\n                                    imgProps={images[i]}\n                                    isCurrentImage={i === currentIndex}\n                                    pagerHeight={pagerHeight}\n                                    pagerIsDragging={isDragging}\n                                    setDisableDrag={setDisableDrag}\n                                    singleClickToZoom={singleClickToZoom}\n                                />\n                                {renderImageOverlay()}\n                            </ImageContainer>\n                        </PagerInnerContentWrapper>\n                    </PagerContentWrapper>\n                </AnimatedImagePager>\n            ))}\n        </>\n    );\n};\n\nImagePager.displayName = 'ImagePager';\n\nexport default ImagePager;\n\nconst PagerInnerContentWrapper = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst PagerContentWrapper = styled.div`\n    width: 100%;\n    display: flex;\n    justify-content: center;\n`;\n\nconst AnimatedImagePager = styled(animated.div)`\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    height: 100%;\n    width: 100%;\n    will-change: transform;\n    touch-action: none;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n`;\n\nconst ImageContainer = styled.div`\n    position: relative;\n    touch-action: none;\n    user-select: none;\n`;\n","import { useState, useEffect } from 'react';\n\ntype IUseWindowSize = {\n    /** window height */\n    height: number;\n    /** window width */\n    width: number;\n};\n\n/**\n * React Hook that returns the current window size\n * and report updates from the 'resize' window event\n *\n * @returns {WindowSize} An object container the window width and height\n */\nconst useWindowSize = (): IUseWindowSize => {\n    const [windowSize, setWindowSize] = useState<IUseWindowSize>({\n        height: window.innerHeight,\n        width: window.innerWidth,\n    });\n\n    useEffect(() => {\n        const handleResize = () => {\n            if (\n                window.innerHeight !== windowSize.height ||\n                window.innerWidth !== windowSize.width\n            ) {\n                setWindowSize({\n                    height: window.innerHeight,\n                    width: window.innerWidth,\n                });\n            }\n        };\n\n        // Add event listener for window resize events\n        window.addEventListener('resize', handleResize);\n        window.addEventListener('orientationchange', handleResize);\n\n        // Remove event listener\n        return () => {\n            window.removeEventListener('resize', handleResize);\n            window.addEventListener('orientationchange', handleResize);\n        };\n    });\n\n    return windowSize;\n};\n\nexport default useWindowSize;\n","import React from 'react';\nimport styled from 'styled-components';\nimport ImagePager from './components/ImagePager';\nimport type { ImagesList } from '../../types/ImagesList';\n\ntype IImageStageProps = {\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Array of image objects to be shown in Lightbox */\n    images: ImagesList;\n    /** Function that closes the Lightbox */\n    onClose: () => void;\n    /** Function that can be called to disable dragging in the pager */\n    onNext: () => void;\n    /** True if this image is currently shown in pager, otherwise false */\n    onPrev: () => void;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay: () => React.ReactNode;\n    /** A React component that is used for next button in image pager */\n    renderNextButton: ({ canNext }: { canNext: boolean }) => React.ReactNode;\n    /** A React component that is used for previous button in image pager */\n    renderPrevButton: ({ canPrev }: { canPrev: boolean }) => React.ReactNode;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom: boolean;\n};\n\n/**\n * Containing element for ImagePager and prev/next button controls\n */\nconst ImageStage = ({\n    currentIndex,\n    images,\n    onClose,\n    onNext,\n    onPrev,\n    renderImageOverlay,\n    renderNextButton,\n    renderPrevButton,\n    singleClickToZoom,\n}: IImageStageProps) => {\n    // Extra sanity check that the next/prev image exists before moving to it\n    const canPrev = currentIndex > 0;\n    const canNext = currentIndex + 1 < images.length;\n\n    return (\n        <ImageStageContainer\n            className=\"lightbox-image-stage\"\n            data-testid=\"lightbox-image-stage\"\n        >\n            {renderPrevButton({ canPrev })}\n            <ImagePager\n                currentIndex={currentIndex}\n                images={images}\n                onClose={onClose}\n                onNext={onNext}\n                onPrev={onPrev}\n                renderImageOverlay={renderImageOverlay}\n                singleClickToZoom={singleClickToZoom}\n            />\n            {renderNextButton({ canNext })}\n        </ImageStageContainer>\n    );\n};\n\nexport default ImageStage;\n\nconst ImageStageContainer = styled.div`\n    flex-grow: 1;\n    position: relative;\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n","import React from 'react';\nimport { useTransition, animated, config } from '@react-spring/web';\nimport styled from 'styled-components';\n\ntype IPageContainerProps = {\n    /** All child components of Lightbox */\n    children: React.ReactNode[];\n    /** Classes are applied to the root lightbox component */\n    className: string;\n    /** Flag that dictates if the lightbox is open or closed */\n    isOpen: boolean;\n    /** React-Spring useTransition config for page open/close animation */\n    pageTransitionConfig: any;\n    /** Inline styles are applied to the root lightbox component */\n    style: React.CSSProperties;\n};\n\n/**\n * Animates the lightbox as it opens/closes\n */\nconst PageContainer = ({\n    children,\n    className,\n    isOpen,\n    pageTransitionConfig,\n    style,\n}: IPageContainerProps) => {\n    const defaultTransition = {\n        config: { ...config.default, friction: 32, mass: 1, tension: 320 },\n        enter: { opacity: 1, transform: 'scale(1)' },\n        from: { opacity: 0, transform: 'scale(0.75)' },\n        leave: { opacity: 0, transform: 'scale(0.75)' },\n    };\n\n    const transitions = useTransition(isOpen, {\n        ...defaultTransition,\n        ...pageTransitionConfig,\n    });\n\n    return (\n        <>\n            {transitions(\n                (animatedStyles, item) =>\n                    item && (\n                        <AnimatedPageContainer\n                            className={`lightbox-container${\n                                className ? ` ${className}` : ''\n                            }`}\n                            data-testid=\"lightbox-container\"\n                            style={{ ...animatedStyles, ...style }}\n                        >\n                            {children}\n                        </AnimatedPageContainer>\n                    )\n            )}\n        </>\n    );\n};\n\nexport default PageContainer;\n\nconst AnimatedPageContainer = styled(animated.div)`\n    display: flex;\n    flex-direction: column;\n    position: fixed;\n    z-index: 400;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\ntype ICreatePortal = {\n    children: React.ReactNode;\n};\n\n/**\n * Creates a SSR + next.js friendly React Portal inside <body />\n *\n * Child components are rendered on the client side only\n\n * @see https://reactjs.org/docs/portals.html\n */\nclass CreatePortal extends React.Component<ICreatePortal> {\n    portalContainer: HTMLDivElement;\n    body: HTMLElement;\n\n    // Only executes on the client-side\n    componentDidMount() {\n        // Get the document body\n        this.body = document.body;\n\n        // Create a container <div /> for React Portal\n        this.portalContainer = document.createElement('div');\n        this.portalContainer.setAttribute('class', 'lightbox-portal');\n\n        // Append the container to the document body\n        this.body.appendChild(this.portalContainer);\n\n        // Force a re-render as we're on the client side now\n        // children prop will render to portalContainer\n        this.forceUpdate();\n\n        // Add event listener to prevent trackpad/ctrl+mousewheel zooming of lightbox\n        // Zooming is handled specifically within /ImageStage/components/Image\n        this.portalContainer.addEventListener('wheel', this.preventWheel);\n    }\n\n    componentWillUnmount() {\n        // Remove wheel event listener\n        this.portalContainer.removeEventListener('wheel', this.preventWheel);\n\n        // Cleanup Portal from DOM\n        this.body.removeChild(this.portalContainer);\n    }\n\n    preventWheel = (e: WheelEvent) => e.preventDefault();\n\n    render(): React.ReactPortal | null {\n        // Return null during SSR\n        if (this.portalContainer === undefined) return null;\n\n        const { children } = this.props;\n\n        return ReactDOM.createPortal(children, this.portalContainer);\n    }\n}\n\nexport default CreatePortal;\n","import React, { useEffect } from 'react';\nimport { ImageStage, PageContainer, CreatePortal } from './components';\nimport type { ImagesList } from './types/ImagesList';\n\nexport type ImagesListType = ImagesList;\n\ntype ILightboxProps = {\n    /** classnames are applied to the root lightbox component */\n    className?: string;\n    /** Index of image in images array that is currently shown */\n    currentIndex: number;\n    /** Array of images to be shown in Lightbox, each image object may contain any valid 'img' attribute with the exceptions of 'draggable', 'onClick', 'onDragStart' and 'ref' */\n    images: ImagesList;\n    /** Flag that dictates if the lightbox is open or closed */\n    isOpen: boolean;\n    /** Function that closes the Lightbox */\n    onClose: () => void;\n    /** Function that changes currentIndex to next image in images */\n    onNext: () => void;\n    /** Function that changes currentIndex to previous image in images */\n    onPrev: () => void;\n    /** React-Spring useTransition config for page open/close animation */\n    pageTransitionConfig?: any;\n    /** A React component that renders below the image pager */\n    renderFooter?: () => React.ReactNode;\n    /** A React component that renders above the image pager */\n    renderHeader?: () => React.ReactNode;\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\n    renderImageOverlay?: () => React.ReactNode;\n    /** A React component that is used for next button in image pager */\n    renderNextButton?: () => React.ReactNode;\n    /** A React component that is used for previous button in image pager */\n    renderPrevButton?: () => React.ReactNode;\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\n    singleClickToZoom?: boolean;\n    /** Inline styles that are applied to the root lightbox component */\n    style?: React.CSSProperties;\n};\n\n/**\n * Gesture controlled lightbox that interpolates animations with spring physics.\n *\n * Demos and docs:\n * @see https://timellenberger.com/libraries/react-spring-lightbox\n *\n * GitHub repo:\n * @see https://github.com/tim-soft/react-spring-lightbox\n *\n * Built with:\n * @see https://github.com/react-spring/react-use-gesture\n * @see https://github.com/react-spring/react-spring\n * @see https://github.com/styled-components/styled-components\n */\nconst Lightbox = ({\n    isOpen,\n    onClose,\n    images = [],\n    currentIndex,\n    onPrev,\n    onNext,\n    renderHeader = () => null,\n    renderFooter = () => null,\n    renderPrevButton = () => null,\n    renderNextButton = () => null,\n    renderImageOverlay = () => null,\n    className = '',\n    singleClickToZoom = false,\n    style = {},\n    pageTransitionConfig = null,\n}: ILightboxProps) => {\n    // Handle event listeners for keyboard\n    useEffect(() => {\n        /**\n         * Prevent keyboard from controlling background page\n         * when lightbox is open\n         */\n        const preventBackgroundScroll = (e: KeyboardEvent) => {\n            const keysToIgnore = [\n                'ArrowUp',\n                'ArrowDown',\n                'End',\n                'Home',\n                'PageUp',\n                'PageDown',\n            ];\n\n            if (isOpen && keysToIgnore.includes(e.key)) e.preventDefault();\n        };\n\n        /**\n         * Navigate images with arrow keys, close on Esc key\n         */\n        const handleKeyboardInput = (e: KeyboardEvent) => {\n            if (isOpen) {\n                switch (e.key) {\n                    case 'ArrowLeft':\n                        onPrev();\n                        break;\n                    case 'ArrowRight':\n                        onNext();\n                        break;\n                    case 'Escape':\n                        onClose();\n                        break;\n                    default:\n                        e.preventDefault();\n                        break;\n                }\n            }\n        };\n\n        document.addEventListener('keyup', handleKeyboardInput);\n        document.addEventListener('keydown', preventBackgroundScroll);\n\n        return () => {\n            document.removeEventListener('keyup', handleKeyboardInput);\n            document.removeEventListener('keydown', preventBackgroundScroll);\n        };\n    });\n\n    return (\n        <CreatePortal>\n            <PageContainer\n                className={className}\n                isOpen={isOpen}\n                pageTransitionConfig={pageTransitionConfig}\n                style={style}\n            >\n                {renderHeader()}\n                <ImageStage\n                    currentIndex={currentIndex}\n                    images={images}\n                    onClose={onClose}\n                    onNext={onNext}\n                    onPrev={onPrev}\n                    renderImageOverlay={renderImageOverlay}\n                    renderNextButton={renderNextButton}\n                    renderPrevButton={renderPrevButton}\n                    singleClickToZoom={singleClickToZoom}\n                />\n                {renderFooter()}\n            </PageContainer>\n        </CreatePortal>\n    );\n};\n\nexport default Lightbox;\n"],"names":["getTranslateOffsetsFromScale","imageRef","scale","pinchDelta","touchOrigin","touchOriginX","touchOriginY","currentTranslate","translateX","translateY","current","_imageRef$current","getBoundingClientRect","imageHeight","height","imageTopLeftX","left","imageTopLeftY","top","width","imageIsOutOfBounds","bottomRightY","bottom","topLeftX","bottomRightX","right","topLeftY","window","windowHeight","innerHeight","windowWidth","innerWidth","defaultImageTransform","pinching","Image","imgProps","imgStyleProp","style","restImgProps","isCurrentImage","pagerHeight","pagerIsDragging","setDisableDrag","singleClickToZoom","useState","isPanningImage","setIsPanningImage","useRef","useSpring","onChange","result","instance","value","start","onRest","springApi","useEffect","get","useGesture","onDrag","movement","xMovement","yMovement","cancel","first","memo","initialTranslateX","initialTranslateY","touches","tap","onDragEnd","undefined","setTimeout","onPinch","origin","event","ctrlKey","last","SCALE_FACTOR","pinchScale","clientX","clientY","newTranslateX","newTranslateY","onPinchEnd","domTarget","drag","filterTaps","eventOptions","passive","ref","latency","onSingleClick","onDoubleClick","timer","clickRef","clickCount","handleClick","e","addEventListener","removeEventListener","clearTimeout","useDoubleClick","stopPropagation","React","AnimatedImage","className","draggable","onClick","nativeEvent","stopImmediatePropagation","onDragStart","preventDefault","maxHeight","transform","to","s","x","y","willChange","displayName","styled","animated","img","ImagePager","currentIndex","images","onClose","onNext","onPrev","renderImageOverlay","firstRender","imageStageRef","_toConsumableArray","Array","length","map","createRef","windowSize","setWindowSize","handleResize","useWindowSize","pageWidth","disableDrag","setPagerHeight","isDragging","setIsDragging","getPagePositions","useCallback","i","down","xDelta","display","useSprings","pagerSprings","springsApi","currImageRef","currPagerHeight","clientHeight","bind","xDir","direction","velocity","distance","active","isHorizontalDrag","Math","abs","goToIndex","onWheel","yDir","onWheelEnd","AnimatedImagePager","key","role","xInterp","PagerContentWrapper","PagerInnerContentWrapper","ImageContainer","div","ImageStage","renderNextButton","renderPrevButton","canPrev","canNext","ImageStageContainer","PageContainer","children","isOpen","pageTransitionConfig","defaultTransition","config","default","friction","mass","tension","enter","opacity","from","leave","transitions","useTransition","animatedStyles","item","AnimatedPageContainer","CreatePortal","body","document","portalContainer","createElement","setAttribute","appendChild","this","forceUpdate","preventWheel","removeChild","props","ReactDOM","createPortal","Component","renderHeader","renderFooter","preventBackgroundScroll","includes","handleKeyboardInput"],"mappings":"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"}